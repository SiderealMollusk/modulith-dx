# Value Object Generator

**Status**: üü† [Not yet implemented](../status.md) ‚Äî this is the specification.

See [docs/ddd-implementation/primitives/value-object/specification.md](../../ddd-implementation/primitives/value-object/specification.md) for full details.

## Quick Start

```bash
nx generate @local/ddd:value-object --context=identity --name=Email
```

Creates:
```
src/core/identity/domain/value-objects/
‚îú‚îÄ‚îÄ Email.ts (generated)
‚îî‚îÄ‚îÄ Email.spec.ts (generated)
```

See [TEMPLATE.md](TEMPLATE.md) for common patterns (base class, private constructor, Result type, etc).

## Generated Structure

### ValueObject Class
```typescript
export class Email extends ValueObject<string> {
  private constructor(readonly value: string) {
    super(value);
  }

  static create(email: string): Result<Email, DomainError> {
    if (!this.isValid(email)) {
      return Result.fail(new DomainError('INVALID_EMAIL', 'Email format invalid'));
    }
    return Result.ok(new Email(email));
  }

  private static isValid(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email) && email.length <= 254;
  }

  toString(): string {
    return this.value;
  }
}
```

### Test Template
```typescript
describe('Email ValueObject', () => {
  describe('create', () => {
    it('should create valid email', () => {
      const result = Email.create('user@example.com');
      expect(result.isSuccess).toBe(true);
      expect(result.value?.value).toBe('user@example.com');
    });
  });

  describe('validation', () => {
    it('should reject invalid email', () => {
      const result = Email.create('not-an-email');
      expect(result.isFailure).toBe(true);
    });
  });

  describe('equality', () => {
    it('should equal same value', () => {
      const email1 = Email.create('user@example.com').value!;
      const email2 = Email.create('user@example.com').value!;
      expect(email1.equals(email2)).toBe(true);
    });
  });

  describe('immutability', () => {
    it('should be immutable', () => {
      const email = Email.create('user@example.com').value!;
      expect(() => {
        // @ts-expect-error
        email.value = 'other@example.com';
      }).toThrow();
    });
  });
});
```

## Key Features

- ‚úÖ Extends `ValueObject<T>`
- ‚úÖ Immutable (readonly fields)
- ‚úÖ Private constructor + static factory
- ‚úÖ Returns `Result<ValueObject, DomainError>`
- ‚úÖ Validation via Zod or custom logic
- ‚úÖ Structural equality (ValueObject.equals)
- ‚úÖ Includes unit test stub

## Key Rules

‚úÖ **DO**:
- Validate in static factory
- Use structural equality for comparison
- Make all fields readonly
- Return Result<ValueObject, DomainError>
- Implement custom validation logic

‚ùå **DON'T**:
- Create value objects with invalid state
- Use reference equality (identity)
- Include business logic beyond validation
- Throw exceptions (return Result instead)

## Related Documentation

- [ValueObject specification](../../ddd-implementation/primitives/value-object/specification.md)
- [Entity generator](entity.md) ‚Äî Uses ValueObjects
- [Brand types](../../ddd-implementation/primitives/entity/specification.md#identity) ‚Äî Specialized ValueObjects for IDs

---

See [generators/README.md](README.md) for overview of all generators.

## Template: {Name}.specification.md (generate alongside the value object)

Use this exact content when scaffolding the instance-level spec for a value object. Keep it delta-focused; defer to the parent spec for general rules.

```markdown
# {Name} Value Object Specification

**Parent spec**: ../../ddd-implementation/primitives/value-object/specification.md  
**Purpose**: capture only instance-specific details; omit anything identical to the parent.

## What this value object represents (1‚Äì2 sentences)
- [FILL IN: meaning and context]
- [FILL IN: why it must exist as a VO]

## Allowed shape and validation
- [FILL IN: format/range rules; canonicalization]
- [FILL IN: invariants unique here]

## Equality and serialization
- [FILL IN: equality semantics; serialization format if special]

## Error cases (instance-specific)
- [FILL IN: validation failures unique here]

## Observability (only if special)
- [FILL IN or ‚ÄúNone‚Äù]

## Related docs
- Parent: ../../ddd-implementation/primitives/value-object/specification.md
- Neighbors: [FILL IN other relevant specs]

**Generated by**: nx generate @local/ddd:value-object --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```

## Template: {Name}.enforcement.md (generate alongside the value object)

Generate this file verbatim. It documents instance-specific guardrails beyond the parent enforcement contract.

```markdown
# {Name} Value Object Enforcement

**Parent enforcement**: ../../ddd-implementation/primitives/value-object/enforcement.md  
**Purpose**: capture only what is unique to this value object; the parent already enforces the rest.

## Why this value object is sensitive
- [FILL IN: critical identifiers/fields; security/regulatory concerns]
- [FILL IN: systems depending on exact format]

## Required shape & validation deltas
- [FILL IN: format/range/canonicalization rules that must not change silently]
- [FILL IN: immutability/equality nuances if special]

## Safe changes checklist (impact map)
- If format changes: update validators, serializers, consumers, database constraints
- If equality/normalization changes: update comparisons, caches/keys, tests

## Minimal tests required
- Creation: happy path + key validation failures
- Equality: structural equality cases
- Serialization (if special): round-trip of canonical form

## Collaborators
- Callers: [FILL IN: factories/entities/use cases using it]
- Consumers: [FILL IN: places relying on its serialization/string form]

## Anti-patterns (instance-specific)
- [FILL IN: unique bans beyond parent, e.g., allowing non-canonical strings]

## Observability (only if special)
- [FILL IN tracing/logging requirements] or ‚ÄúNone‚Äù

**Generated by**: nx generate @local/ddd:value-object --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```
