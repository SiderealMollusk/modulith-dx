# Query Generator

**Status**: üü† [Not yet implemented](../status.md) ‚Äî this is the specification.

## When to Use

Create a **Query** when you need to **read data** without mutation:
- Fetch user by ID
- List orders for customer
- Search products
- Calculate report totals

**Not for**: Mutating state (use Command instead).

## Quick Start

```bash
nx generate @local/ddd:query --context=orders --name=GetOrdersByCustomer --result="Order[]"
```

Creates:
```
src/core/orders/application/queries/
‚îú‚îÄ‚îÄ GetOrdersByCustomer.ts
‚îú‚îÄ‚îÄ GetOrdersByCustomer.validation.spec.ts
‚îú‚îÄ‚îÄ GetOrdersByCustomer.serialization.spec.ts
‚îî‚îÄ‚îÄ index.ts (updated)
```

See [TEMPLATE.md](TEMPLATE.md) for common patterns (base class, private constructor, Result type, etc).

## Key Differences from Command

| Aspect | Command | Query |
|--------|---------|-------|
| **Purpose** | Mutate state | Read data |
| **Idempotency** | ‚úÖ Via `id` field | N/A (read-only) |
| **Caching** | ‚ùå No | ‚úÖ Via `cacheKey` |
| **Side effects** | Changes database | None |

## Unique Features

### 1. Cache Key Support

```typescript
export class GetUserById extends Query<UserDto> {
  readonly cacheKey: string;

  private constructor(
    readonly userId: string,
    readonly cacheKey: string, // Key for Redis/in-memory cache
  ) {
    super();
  }

  static create(userId: string): Result<GetUserById, ValidationError> {
    return Result.ok(new GetUserById(
      userId,
      `user:${userId}`, // Cache key pattern
    ));
  }
}
```

### 2. Handler Cache Usage

```typescript
async handle(req): Promise<Result<UserDto, Error>> {
  const query = GetUserById.create(req.params.id).value!;

  // Check cache
  const cached = await this.cache.get(query.cacheKey);
  if (cached) return Result.ok(cached);

  // Cache miss: execute query
  const result = await this.useCase.execute(query);
  if (result.isSuccess) {
    await this.cache.set(query.cacheKey, result.value, 300); // 5 min TTL
  }
  return result;
}
```

## Test Files

Same as Command generator:

1. **`{Name}.validation.spec.ts`** ‚Äî Zod schema tests
2. **`{Name}.serialization.spec.ts`** ‚Äî Round-trip tests

## Key Rules

‚úÖ **DO**:
- Use Zod for validation schema
- Return `Result<Query, ValidationError>` from factory
- Implement `cacheKey` for caching strategy
- Make all fields `readonly`
- Implement `toPrimitives()` + `fromPrimitives()`

‚ùå **DON'T**:
- Query with side effects (use Command for mutations)
- Throw exceptions (return Result instead)
- Make query mutable
- Forget cache key strategy

## Related Documentation

- [Query specification](../../ddd-implementation/primitives/query/specification.md)
- [Command Generator](command.md) ‚Äî Similar structure, different purpose
- [ADR-0002: Command/Query as First-Class Primitives](../../architecture-decisions/accepted/command-query-as-primitives.md)
- [UseCase spec](../../ddd-implementation/primitives/use-case/specification.md) ‚Äî Queries are input to use cases

---

See [generators/README.md](README.md) for overview of all generators.

## Template: {Name}.specification.md (generate alongside the query)

Use this exact content when scaffolding the instance-level spec for a query. Keep it delta-focused; defer to the parent spec for general rules.

```markdown
# {Name} Query Specification

**Parent spec**: ../../ddd-implementation/primitives/query/specification.md  
**Purpose**: capture only instance-specific details; omit anything identical to the parent.

## What this query does (1‚Äì2 sentences)
- [FILL IN: business question answered]
- [FILL IN: consumers of the data]

## Inputs and meaning
- [FILL IN: required/optional fields; semantics]
- [FILL IN: constraints/defaults unique here]

## Cache key and consistency
- [FILL IN: cacheKey shape/pattern; TTL/invalidation rules]
- [FILL IN: staleness/consistency expectations]

## Serialization and lifecycle
- [FILL IN: fields that must survive round-trip; versioning if any]
- [FILL IN: correlation/tracing requirements if special]

## Error cases (instance-specific)
- [FILL IN: validation failures or business rejections unique here]

## Observability (only if special)
- [FILL IN or ‚ÄúNone‚Äù]

## Related docs
- Parent: ../../ddd-implementation/primitives/query/specification.md
- Neighbors: [FILL IN other relevant specs]

**Generated by**: nx generate @local/ddd:query --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```

## Template: {Name}.enforcement.md (generate alongside the query)

Generate this file verbatim. It documents instance-specific guardrails beyond the parent enforcement contract.

```markdown
# {Name} Query Enforcement

**Parent enforcement**: ../../ddd-implementation/primitives/query/enforcement.md  
**Purpose**: capture only what is unique to this query; the parent already enforces the rest.

## Why this query is sensitive
- [FILL IN: critical read path, SLAs, regulatory constraints]
- [FILL IN: consumers relying on specific shape/cache behavior]

## Required shape & schema deltas
- [FILL IN: fields that must not be removed/renamed; semantics]
- [FILL IN: cacheKey requirements and invalidation rules]

## Safe changes checklist (impact map)
- If fields change: update schema, serialization, handlers, consumers, caching
- If cache strategy changes: update TTL/invalidation and client expectations
- If correlation/tracing changes: update middleware and tests

## Minimal tests required
- Validation: happy path + representative failures for key invariants
- Serialization: round-trip keeps cacheKey and critical fields
- Cache behavior (if special): ensures TTL/invalidation rules are honored

## Collaborators
- Callers: [FILL IN: which handler/use case constructs it]
- Consumers: [FILL IN: which use case executes it; downstream listeners relying on payload]

## Anti-patterns (instance-specific)
- [FILL IN: unique bans beyond parent, e.g., side effects]

## Observability (only if special)
- [FILL IN tracing/logging requirements] or ‚ÄúNone‚Äù

**Generated by**: nx generate @local/ddd:query --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```
