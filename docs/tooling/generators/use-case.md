# Use Case Generator

**Status**: üü† [Not yet implemented](../status.md) ‚Äî this is the specification.

See [docs/ddd-implementation/primitives/use-case/specification.md](../../ddd-implementation/primitives/use-case/specification.md) for full details.

## Quick Start

```bash
nx generate @local/ddd:use-case --context=orders --name=PlaceOrder
```

Creates:
```
src/core/orders/application/use-cases/
‚îú‚îÄ‚îÄ PlaceOrderUseCase.ts (generated)
‚îú‚îÄ‚îÄ PlaceOrderUseCase.spec.ts (generated unit test)
‚îî‚îÄ‚îÄ PlaceOrderUseCase.integration.spec.ts (optional stub)
```

See [TEMPLATE.md](TEMPLATE.md) for common patterns (base class, dependency injection, Result type, etc).

## Generated Structure

### UseCase Class
```typescript
export class PlaceOrderUseCase extends BaseUseCase<PlaceOrderInput, OrderDto> {
  constructor(
    private orderRepository: OrderRepository,
    private eventBus: EventBus,
    // ... other dependencies
  ) {
    super();
  }

  async execute(input: PlaceOrderInput): Promise<Result<OrderDto, ApplicationError>> {
    // 1. Validate input via domain
    // 2. Load aggregates from repositories
    // 3. Perform business logic
    // 4. Save changes
    // 5. Publish domain events
    // 6. Return DTO

    return Result.ok(orderDto);
  }
}
```

### Test Template (Unit)
```typescript
describe('PlaceOrderUseCase (Unit)', () => {
  let useCase: PlaceOrderUseCase;
  let orderRepository: MockOrderRepository;

  beforeEach(() => {
    orderRepository = new MockOrderRepository();
    useCase = new PlaceOrderUseCase(
      orderRepository,
      // ... other mocks
    );
  });

  describe('happy path', () => {
    it('should place valid order', async () => {
      const result = await useCase.execute({
        customerId: 'cust-123',
        items: [{ sku: 'WIDGET', quantity: 5 }],
      });

      expect(result.isSuccess).toBe(true);
      expect(result.value?.id).toBeDefined();
    });
  });

  describe('validation failures', () => {
    it('should reject empty items', async () => {
      const result = await useCase.execute({
        customerId: 'cust-123',
        items: [],
      });

      expect(result.isFailure).toBe(true);
    });
  });

  describe('business rule failures', () => {
    it('should reject if customer not found', async () => {
      // Setup: customer doesn't exist in mock
      const result = await useCase.execute({
        customerId: 'unknown',
        items: [{ sku: 'WIDGET', quantity: 5 }],
      });

      expect(result.isFailure).toBe(true);
    });
  });
});
```

## Key Features

- ‚úÖ Extends `BaseUseCase<TInput, TOutput>`
- ‚úÖ Async execute method
- ‚úÖ Returns `Result<T, ApplicationError>`
- ‚úÖ Full observability (logging, tracing, metrics via base class)
- ‚úÖ Dependencies injected via constructor
- ‚úÖ Unit tests with mocks
- ‚úÖ Integration test stub (optional)

## Key Rules

‚úÖ **DO**:
- Take Commands/Queries as input
- Load aggregates from repositories
- Perform domain operations
- Return DTOs (not entities)
- Publish domain events
- Inject dependencies via constructor
- Write both unit and integration tests

‚ùå **DON'T**:
- Query database directly (use repositories)
- Include HTTP/gRPC logic (handlers do that)
- Throw exceptions (return Result instead)
- Return domain entities (convert to DTOs)
- Skip testing for edge cases

## Related Documentation

- [UseCase specification](../../ddd-implementation/primitives/use-case/specification.md)
- [Handler generator](handler.md) ‚Äî Handlers call use cases
- [Command/Query generators](command.md) ‚Äî Input to use cases
- [Repository generator](repository.md) ‚Äî Dependencies for use cases

---

See [generators/README.md](README.md) for overview of all generators.

## Template: {Name}.specification.md (generate alongside the use case)

Use this exact content when scaffolding the instance-level spec for a use case. Keep it delta-focused; defer to the parent spec for general rules.

```markdown
# {Name} Use Case Specification

**Parent spec**: ../../ddd-implementation/primitives/use-case/specification.md  
**Purpose**: capture only instance-specific details; omit anything identical to the parent.

## What this use case does (1‚Äì2 sentences)
- [FILL IN: business goal/outcome]
- [FILL IN: primary inputs (commands/queries) and outputs (DTO/events)]

## Flow and steps
- [FILL IN: key steps; repositories/services touched]
- [FILL IN: transaction boundaries and ordering]

## Invariants and rules
- [FILL IN: domain/application rules enforced here]
- [FILL IN: retries/idempotency/versioning if special]

## Error handling
- [FILL IN: expected error types/codes surfaced]
- [FILL IN: compensations/rollbacks if any]

## Observability
- [FILL IN: tracing/logging/metrics requirements if special]

## Related docs
- Parent: ../../ddd-implementation/primitives/use-case/specification.md
- Neighbors: [FILL IN other relevant specs]

**Generated by**: nx generate @local/ddd:use-case --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```

## Template: {Name}.enforcement.md (generate alongside the use case)

Generate this file verbatim. It documents instance-specific guardrails beyond the parent enforcement contract.

```markdown
# {Name} Use Case Enforcement

**Parent enforcement**: ../../ddd-implementation/primitives/use-case/enforcement.md  
**Purpose**: capture only what is unique to this use case; the parent already enforces the rest.

## Why this use case is sensitive
- [FILL IN: critical business flow, SLAs, regulatory constraints]
- [FILL IN: downstream systems depending on its outputs/events]

## Required behavior & contract deltas
- [FILL IN: steps/ordering that must not change silently]
- [FILL IN: inputs/outputs that are contractually relied upon]

## Safe changes checklist (impact map)
- If inputs/outputs change: update contracts, handlers, tests, DTO mappers
- If repo/event interactions change: update ports, adapters, policies, tests
- If observability or idempotency changes: update middleware/hooks and tests

## Minimal tests required
- Happy path covering main flow and outputs/events
- Failure paths for key invariants and repo interactions
- Idempotency/versioning/transactional behaviors if applicable

## Collaborators
- Callers: [FILL IN: which handlers invoke it]
- Dependencies: [FILL IN: repositories/services/event buses]

## Anti-patterns (instance-specific)
- [FILL IN: unique bans beyond parent]

## Observability (only if special)
- [FILL IN tracing/logging requirements] or ‚ÄúNone‚Äù

**Generated by**: nx generate @local/ddd:use-case --context={context} --name={name}  
**Last updated**: [Auto-generated date]
```
